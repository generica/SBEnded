#!/usr/bin/env python

'''
Parse a sickbeard sqlite file and check for any ended shows
now marked as continuing on thetvdb

Written by Brett Pemberton, brett@whatevz.net
Copyright (C) 2011

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

'''

import sys
import getopt
import os
import sqlite3
import tvdb_api
import tvdb_exceptions
import logging


def check_shows(shows):

    to_fix = []
    t = tvdb_api.Tvdb()

    for (tvdb_id, show_name, status) in shows:
        log.info("Checking %s ", show_name)
        try:
            show = t[show_name]
            show_id = show['id']
        except tvdb_exceptions.tvdb_shownotfound:
            log.warn("Warning: Couldn't find show %s on tvdb", show_name)
            continue
        except:
            log.warn("Unknown error with show %s", show_name)
            continue
        if int(tvdb_id) != int(show_id):
            log.error("Warning: Issue matching %s on tvdb. Got %s and %s",
                      show_name, tvdb_id, show_id)
        else:
            show_status = show['status']
            if show_status != status:
                log.error("Show %s with local status %s is now %s on thetvdb",
                          show_name, status, show_status)
                to_fix.append(show_id)
            else:
                log.info("Local status matches thetvdb: %s", status)

    return to_fix


def read_sickbeard_sqlite_file(sqlite_file):
    conn = sqlite3.connect(sqlite_file)
    cur = conn.cursor()
    try:
        cur.execute("SELECT tvdb_id,show_name,status FROM tv_shows WHERE status != 'Continuing' ORDER BY show_name")
    except sqlite3.DatabaseError:
        log.error("ERROR: Not a SickBeard sqlite file")
        sys.exit(-1)
    shows = cur.fetchall()

    conn.close()

    return shows


def update_sickbeard_sqlite_file(sqlite_file, shows):
    conn = sqlite3.connect(sqlite_file)
    cur = conn.cursor()
    for show in shows:
        cur.execute("update tv_shows set status = 'Continuing' where tvdb_id = %s" % show)

    conn.commit()
    conn.close()

    return shows


def usage():
    print "usage: SBEnded [-v] [-h] [-f] -s <sqlite file>"
    print "   -s : sqlite file to use"
    print "   -f : fix local status"
    print "   -v : verbose"
    print "   -h : help"


if __name__ == "__main__":

    sqlite_file = False
    fix = False

    log = logging.getLogger('SBEnded')
    log.addHandler(logging.StreamHandler())

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'vhfs:')
    except getopt.GetoptError, err:
        log.error(str(err))
        usage()
        sys.exit(2)
    opts = dict(opts)

    if '-v' in opts:
        log.setLevel(logging.INFO)

    if '-f' in opts:
        fix = True

    if '-h' in opts:
        usage()
        sys.exit(1)

    if '-s' in opts:
        sqlite_file = opts['-s']
    else:
        usage()
        sys.exit(1)

    if not os.path.isfile(sqlite_file):
        log.error("ERROR: %s is not a file", sqlite_file)
        sys.exit(-1)

    shows = read_sickbeard_sqlite_file(sqlite_file)
    to_fix = check_shows(shows)

    if fix:
        update_sickbeard_sqlite_file(sqlite_file, to_fix)
